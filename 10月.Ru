# 1. å¤‰æ•° name ã«è‡ªåˆ†ã®åå‰ã‚’ä»£å…¥ã—ã¦è¡¨ç¤ºã›ã‚ˆã€‚
name = "YourName"
puts name

# 2. å¤‰æ•° x=10, y=5 ã‚’ç”¨æ„ã—ã€å’Œãƒ»å·®ãƒ»ç©ãƒ»å•†ã‚’å‡ºåŠ›ã›ã‚ˆã€‚
x = 10
y = 5
puts x + y
puts x - y
puts x * y
puts x / y

# 3. å¤‰æ•° num=7 ãŒå¶æ•°ãªã‚‰ "Even"ã€å¥‡æ•°ãªã‚‰ "Odd" ã¨è¡¨ç¤ºã›ã‚ˆã€‚
num = 7
if num.even?
  puts "Even"
else
  puts "Odd"
end

# 4. æ–‡å­—åˆ— "Ruby" ã®é•·ã•ã‚’è¡¨ç¤ºã›ã‚ˆã€‚
puts "Ruby".length

# 5. "hello" ã‚’å¤§æ–‡å­—ã«å¤‰æ›ã—ã¦è¡¨ç¤ºã›ã‚ˆã€‚
puts "hello".upcase

# 6. "WORLD" ã‚’å°æ–‡å­—ã«å¤‰æ›ã—ã¦è¡¨ç¤ºã›ã‚ˆã€‚
puts "WORLD".downcase   # â† typoä¿®æ­£

# 7. å¤‰æ•° a=3.7 ã‚’å››æ¨äº”å…¥ã—ã¦æ•´æ•°ã«ã›ã‚ˆã€‚
a = 3.7
puts a.round

# 8. æ–‡å­—åˆ— "Ruby Ruby Ruby" ã‹ã‚‰ "Ruby" ã®å‡ºç¾å›æ•°ã‚’æ•°ãˆã‚ˆã€‚
r = "Ruby Ruby Ruby"
puts r.scan("Ruby").length

# 9. é…åˆ— [1,2,3,4,5] ã®è¦ç´ æ•°ã‚’è¡¨ç¤ºã›ã‚ˆã€‚
a = [1,2,3,4,5]
puts a.length

# 10. é…åˆ— [1,2,3,4,5] ã®å…ˆé ­ã¨æœ«å°¾ã‚’è¡¨ç¤ºã›ã‚ˆã€‚
a = [1,2,3,4,5]
puts a.first
puts a.last

# 11. å¤‰æ•° x=12 ã®å¹³æ–¹æ ¹ã‚’æ±‚ã‚ã‚ˆã€‚
x = 12
puts Math.sqrt(x)

# 12. 10..20 ã®ç¯„å›²ã§å¶æ•°ã®ã¿å‡ºåŠ›ã›ã‚ˆã€‚
puts (10..20).select(&:even?).to_s  # â† even? ã«ä¿®æ­£

# 13. 1ã€œ10 ã®å’Œã‚’è¨ˆç®—ã—ã¦è¡¨ç¤ºã›ã‚ˆã€‚
puts (1..10).sum

# 14. rand(1..6) ã‚’ä½¿ã£ã¦ã‚µã‚¤ã‚³ãƒ­ã‚’æŒ¯ã‚Šã€ãã®ç›®ã‚’è¡¨ç¤ºã›ã‚ˆã€‚
puts rand(1..6)

# 15. gets ã‚’ä½¿ã£ã¦å…¥åŠ›ã‚’å—ã‘å–ã‚Šã€ "Hello, å…¥åŠ›å€¤!" ã‚’è¡¨ç¤ºã›ã‚ˆã€‚
# å®Ÿè¡Œæ™‚ã«å…¥åŠ›ãŒå¿…è¦
# s = gets.chomp
# puts "Hello, #{s}!"

# 16. æ–‡å­—åˆ— "Ruby" ã‚’é€†é †ã«è¡¨ç¤ºã›ã‚ˆã€‚
puts "Ruby".reverse

# 17. é…åˆ— [10,20,30] ã®åˆè¨ˆã‚’è¨ˆç®—ã›ã‚ˆã€‚
puts [10,20,30].sum

# 18. ãƒãƒƒã‚·ãƒ¥ {name: "Alice", age: 20} ã® :name ã‚’è¡¨ç¤ºã›ã‚ˆã€‚
c = {name: "Alice", age: 20}
puts c[:name]

# 19. é…åˆ— [5,2,9,1] ã‚’æ˜‡é †ã«ã‚½ãƒ¼ãƒˆã›ã‚ˆã€‚
puts [5,2,9,1].sort.to_s

# 20. åŒã˜é…åˆ—ã‚’é™é †ã«ã‚½ãƒ¼ãƒˆã›ã‚ˆã€‚
puts [5,2,9,1].sort.reverse.to_s


# --- 21ã€œ ã®ç¶šã ---

# 21. score=85 ãŒ 80 ä»¥ä¸Šãªã‚‰ "åˆæ ¼"ã€ãã†ã§ãªã‘ã‚Œã° "ä¸åˆæ ¼" ã‚’è¡¨ç¤ºã›ã‚ˆã€‚
score = 85
if score >= 80
  puts "åˆæ ¼"
else
  puts "ä¸åˆæ ¼"
end

# 22. n=3 ãŒæ­£ãªã‚‰ "positive"ã€0 ãªã‚‰ "zero"ã€è² ãªã‚‰ "negative"
n = 3
if n > 0
  puts "positive"
elsif n == 0       # â† elseif â†’ elsif ã«ä¿®æ­£
  puts "zero"
else
  puts "negative"
end

# 23. for i in 1..5 ã‚’ä½¿ã£ã¦ 1ã€œ5 ã‚’å‡ºåŠ›ã›ã‚ˆã€‚
for i in 1..5
  puts i
end

# 24. while ã‚’ä½¿ã£ã¦ 1ã€œ5 ã‚’å‡ºåŠ›ã›ã‚ˆã€‚
i = 1
while i <= 5
  puts i
  i += 1
end

#times ã‚’ä½¿ã£ã¦ "Hello" ã‚’ 3 å›è¡¨ç¤ºã›ã‚ˆã€‚
3.times do
    puts "Hello"
end
#1ã€œ100 ã®å¶æ•°ã®åˆè¨ˆã‚’æ±‚ã‚ã‚ˆã€‚
sum = (1..100).select(&:even?).sum
puts sum

# ä¹ä¹ã®è¡¨ã‚’å‡ºåŠ›ã›ã‚ˆã€‚
for i in 1..9
    for j in 1..9
        print"#{i*j}\t"
    end
end

#é…åˆ— [1,2,3,4,5] ã®å„è¦ç´ ã‚’ 2 å€ã«ã—ã¦å‡ºåŠ›ã›ã‚ˆã€‚
arr=[1,2,3,4,5]
arr.each do | n |
    puts n * 2
end

#[10,20,30] ã®å„è¦ç´ ã‚’åˆè¨ˆã—ã€å¹³å‡ã‚’æ±‚ã‚ã‚ˆã€‚
nums=[10,20,30]
average=nums.sum.to_f / nums.size
puts average

#ãƒãƒƒã‚·ãƒ¥ {a:100,b:200,c:300} ã®ã‚­ãƒ¼ã¨å€¤ã‚’ã™ã¹ã¦è¡¨ç¤ºã›ã‚ˆã€‚
hash ={a:100,b:200,c:300}
hash.each do | key,value|
    puts "#{key}ã¯#{value}ã§ã™"
end

#case æ–‡ã‚’ä½¿ã£ã¦ã€å…¥åŠ›ã—ãŸæ›œæ—¥ã«å¿œã˜ãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºã›ã‚ˆã€‚
day="æœˆ","ç«","æ°´","æœ¨","é‡‘","åœŸ","æ—¥"
case day
when "æœˆ"
    p "æœˆæ›œæ—¥ã§ã™"
when "ç«"
    p "ç«"
when "æ°´"
    p "æ°´"
when "æœ¨"
    p "æœ¨"
when "é‡‘"
    p "é‡‘"
when "åœŸ"
    p "åœŸ"
when "æ—¥"
    p "æ—¥"
else
    p "ã©ã®å­£ç¯€ã§ã‚‚ã‚ã‚Šã¾ã›ã‚“"
end
#break ã‚’ä½¿ã£ã¦ 1ã€œ10 ã®é€”ä¸­ã§ãƒ«ãƒ¼ãƒ—ã‚’çµ‚äº†ã›ã‚ˆã€‚
for i in 1..10
    if i == 3
        break
    end
    puts i
end

#next ã‚’ä½¿ã£ã¦ 1ã€œ10 ã®ã†ã¡å¶æ•°ã‚’ã‚¹ã‚­ãƒƒãƒ—ã›ã‚ˆã€‚
for i in 1..10
    if i.even?
        next
    end
    puts i
end
#é…åˆ— [1,2,3,4,5] ã‹ã‚‰ 3 ä»¥ä¸Šã®è¦ç´ ã ã‘ã‚’å–ã‚Šå‡ºã›ã€‚
ary=[1,2,3,4,5]
new_arr=ary.select{| n | n > = 3 }
p new_arr
#1ã€œ50 ã®ä¸­ã§ 3 ã®å€æ•°ã‚’å‡ºåŠ›ã›ã‚ˆã€‚
for i in 1..50
    if i % 3==0
        puts i
    end
end

#ãƒ•ã‚£ãƒœãƒŠãƒƒãƒæ•°åˆ—ã‚’ 10 é …è¡¨ç¤ºã›ã‚ˆã€‚
a,b=0,1
10.times do
    puts a
    a,b =b,a+b
end

#ç´ æ•°åˆ¤å®šã‚’è¡Œã†ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ã‘ã€‚
def prima(n)
    return false if n < 2
    (2..Math.sprt(n)).each do | i |
        return false if n % i ==0
    end
    true
end
p prima?(7)
p prima?(6)
#å…¥åŠ›ã—ãŸæ•°ã®éšä¹—ã‚’è¨ˆç®—ã›ã‚ˆã€‚
def factor(n)
    return 1 if n <=1
    n * factorial(n - 1)
end
p factorial(5)
#é…åˆ— [apple,banana,orange] ã‚’ "apple, banana, orange" ã¨ã„ã†æ–‡å­—åˆ—ã«å¤‰æ›ã›ã‚ˆã€‚
futis =["apple, banana, orange"]
puts futis.join(",")
#æ–‡å­—åˆ— "abracadabra" ã®å„æ–‡å­—ã®å‡ºç¾å›æ•°ã‚’æ•°ãˆã‚ˆã€‚
str="abracadabra"
couts =Hash.new(0)
str.each_char do |ch|
    couts[ch]+=1
end
puts couts
#41ã€œ60: ãƒ¡ã‚½ãƒƒãƒ‰ãƒ»ã‚¯ãƒ©ã‚¹
#å¼•æ•°ã‚’å—ã‘å–ã‚Šã€ãã®2ä¹—ã‚’è¿”ã™ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã›ã‚ˆã€‚
def nizilyo(n)
    result=n * n
    puts "#{n}ã®äºŒä¹—ã¯#{result}ã§ã™"
    result
end
#æ–‡å­—åˆ—ã‚’å—ã‘å–ã‚Šã€é€†é †ã«ã—ã¦è¿”ã™ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½œã‚Œã€‚
def reverse_string(s)
    s.reverse
end
str="supre"
result=reverse_string(str)
puts result
#é…åˆ—ã®å¹³å‡ã‚’è¿”ã™ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½œã‚Œã€‚
def sum_array(arr)
    srr.sum
end

ke=[10,20,58,40,38,4,5,6,8,3,6]
result= sum_array
p result
#2ã¤ã®æ•°ã‚’å—ã‘å–ã‚Šã€æœ€å¤§å€¤ã‚’è¿”ã™ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½œã‚Œã€‚
def max_to_tow(a,b)
    if a > b
        a
    else
    b
    end
end
puts max_to_tow(7,12)
#ã‚¯ãƒ©ã‚¹ Dog ã‚’ä½œã‚Šã€name ã‚’æŒãŸã›ã€bark ãƒ¡ã‚½ãƒƒãƒ‰ã§ "ãƒ¯ãƒ³!" ã¨å‡ºåŠ›ã›ã‚ˆã€‚
class Dog
    def initialize(name)
        @name=name
    end

    def break
        puts "#{@name}ãƒ¯ãƒ³!"
    end
end
puts Dog.new("ãƒãƒ")
dog.break
#Person ã‚¯ãƒ©ã‚¹ã‚’ä½œã‚Šã€åå‰ã¨å¹´é½¢ã‚’å±æ€§ã¨ã—ã¦æŒãŸã›ã‚ˆã€‚ 
class Person
    def initialize (name,age)
        @name=name
        @age=age
    end
    def initialize
        puts "ç§ã¯#{@name}ã§ã™ã€‚ #{@age}æ­³ã§ã™ã€‚"
    end
end
Person1=Person.new("ã‚¸ãƒ§ãƒ³","20")
Person1.introduce
#ã‚¯ãƒ©ã‚¹ã«ã‚¤ãƒ‹ã‚·ãƒ£ãƒ©ã‚¤ã‚¶ï¼ˆinitializeï¼‰ã‚’ä½¿ã£ã¦åˆæœŸåŒ–ã‚’è¡Œãˆã€‚
class sample
    def initialize(a)
        @a=a
    end
    def show
        puts "å€¤ã¯#{@a}ã§ã™ã€‚"
    end
end

s=Sample.new(10)
s.show
#ã‚¯ãƒ©ã‚¹ã«å¹´é½¢ã‚’è¿”ã™ãƒ¡ã‚½ãƒƒãƒ‰ age ã‚’ä½œã‚Œã€‚
class Age
    def initialize(a)
        @a=a
    end

    def show
        puts "å¹´é½¢ã¯#{}ã§ã™ã€‚"
    end
end

s=Age.new(20)
s.show

#ã‚¯ãƒ©ã‚¹ã« greet ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ ã—ã€"ã“ã‚“ã«ã¡ã¯, åå‰ã§ã™" ã¨è¡¨ç¤ºã›ã‚ˆã€‚
class Greet
    def initialize(name)
        @name=name
    end

    def hello 
        puts "ã“ã‚“ã«ã¡ã¯,#{@name}ã§ã™ã€‚"
    end
end

s = Greet.new("ã‚¸ãƒ§ãƒ³")
s.hello
#attr_accessor ã‚’ä½¿ã£ã¦ã€ã‚¯ãƒ©ã‚¹ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’èª­ã¿æ›¸ãå¯èƒ½ã«ã›ã‚ˆã€‚
class afttr_accessor
    @@my_afttr_accessor="Hello world!"
end
#ã‚¯ãƒ©ã‚¹ç¶™æ‰¿ã‚’ç”¨ã„ã¦ã€Animal â†’ Cat ã‚’ä½œã‚Šã€meow ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ ã›ã‚ˆã€‚
class Animal
    def accele
        puts "å‹•ç‰©"
    end
end
class Cat < Animal
    def meow
        puts "å‹•ç‰©"
    end
end 
c=Cat.new
c.accele
c.meow
#ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å®šç¾©ã—ã€ãƒ¡ã‚½ãƒƒãƒ‰ã‚’1ã¤å«ã‚ã¦ã¿ã‚ˆã€‚
module  Greeting
    def hello
        puts "hello"
    end
end
#ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¯ãƒ©ã‚¹ã« include ã—ã¦å‘¼ã³å‡ºã›ã€‚
class hello
    include Greeting

    def dispGreeting
        hello
    end
end
h=Hello.new
h.dispGreeting

#ã‚¯ãƒ©ã‚¹å¤‰æ•°ã‚’ä½¿ã£ã¦ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®æ•°ã‚’æ•°ãˆã‚ˆã€‚
class S
    @@value=0

    def self.count
        @@count
    end

    def initialize 
        @@count += 1
    end
end

s1=S.new
s2=S.new
s3=S.new

puts "ã‚¤ãƒ³ã‚¿ãƒ³ã‚¹ã®æ•°:#{S.count}"

#ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¦ä½¿ãˆã€‚
class S
    def initialize(a)
        @a=a
    end

    def hello
        puts "hrllo word!"
    end

    def self.greet
        puts "This is a class method"
    end
end

s=S.new
s.hello

S.greet

#self ã‚’ä½¿ã£ã¦ç¾åœ¨ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å‡ºåŠ›ã—ã¦ã¿ã‚ˆã€‚
class S
    def initialize(a)
        @@a=a
    end

    def hello
        puts "hello world!"
        puts "selfã®ä¸­èº«ã¯:#{self}"
    end
end
s=S.new("Ruby")
s.hello

#private ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½œã£ã¦å¤–éƒ¨ã‹ã‚‰å‘¼ã¹ãªã„ã“ã¨ã‚’ç¢ºèªã›ã‚ˆã€‚
class Car
    def accele
        puts ("ã‚¢ã‚¯ã‚»ã‚¹ã‚’è¸ã¿ã¾ã—ãŸ")
    speedChange
    end

    public :accele

    def break
        puts("ãƒ–ãƒ¬ãƒ¼ã‚­ã‚’è¸ã¿ã¾ã—ãŸ")
        speedChange
    end
    public :accele
    def speedChange
        puts ("ã‚¹ãƒ”ãƒ¼ãƒ‰ã‚’å¤‰ã‚ã‚Šã¾ã—ãŸ")
    end
    private :speedChange
end

car=Car.new
car.accele
car.break

#protected ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è©¦ã—ã¦ã¿ã‚ˆã€‚
class Foo
    def initialize(val)
        @val=val
    end

    protected
    def value
        @val
    end

    def compare(other)
        if self.value > other.value
            puts "è‡ªåˆ†ã®æ–¹ãŒå¤§ãã„"
        elsif self.value < other.value
            puts "ç›¸æ‰‹ã®æ–¹ãŒå¤§ãã„"
        else
            puts "åŒã˜ä¸ãˆã§ã™"
        end
    end
end
f1=Foo.new(10)
f2=Foo.new(5)
f1.compare(f2)

#æ¼”ç®—å­ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ï¼ˆ+ ã‚’å®šç¾©ï¼‰ã‚’è©¦ã—ã¦ã¿ã‚ˆã€‚
class Vector
    def initialize(x,y)
        @a=a
        @b=b
    end

    def +(other)
        if other.is_a?(Vector)
            Vector.new(@a + other.x, @b+other.y)
        else
            raise TypeError
        end
    end
end

v1=Vector.new(1,2)
v2=Vector.new(3,4)
v3=v1 + v2 

puts v3
#ã‚¯ãƒ©ã‚¹ã« to_s ã‚’å®šç¾©ã—ã¦ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ–‡å­—åˆ—åŒ–ã›ã‚ˆã€‚
class Myobject
    def initialize(name)
        @name=name
    end

    def to_s
        "ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åå‰ã¯#{}ã§ã™"
    end
end

obj=Myobject.new("Ruby")
puts obj

#61ã€œ80: ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œãƒ»ä¾‹å¤–å‡¦ç†
#"test.txt" ã« "Hello Ruby" ã‚’æ›¸ãè¾¼ã‚ã€‚
File.open("test.txt","w"){|f|
    f.write("hello Ruby") 
} 
#åŒã˜ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§å†…å®¹ã‚’è¡¨ç¤ºã›ã‚ˆã€‚
File.open("text.tet","r")do |f|
    puts f.read
end
#ãƒ•ã‚¡ã‚¤ãƒ«ã«é…åˆ—ã®å†…å®¹ã‚’æ›¸ãè¾¼ã‚ã€‚
File.opne(test.text)do |f|
    puts f.read
end

#ãƒ•ã‚¡ã‚¤ãƒ«ã‚’1è¡Œãšã¤èª­ã¿è¾¼ã‚“ã§è¡¨ç¤ºã›ã‚ˆã€‚
File.opne('test.txt', "r:utf-8") do |f|
    while line = f.gets

        if line.include?("æ´ªåºµ")
        puts line
        end
    end
end
#JSON ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œã£ã¦ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚ã€‚
require 'json'
data={
    name:"Alce",
    age:"20",
    skills:["Ruby","python","C"]
}
File.opne("data.json","w") do |f|
    f.write(JSON.pretty_generate(data))
end
puts "JSONã‚’æ›¸ãè¾¼ã¿ã¾ã—ãŸã€‚"
#JSON ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ãƒ‘ãƒ¼ã‚¹ã›ã‚ˆã€‚
require "json"
file=File.read("data.json")
data=JSON.parse(file)
p data
#CSV ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ã¦ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚ã€‚
require "csv"
CSV.open("text.csv","w") do |csv|
    csv << ["name","age","city"]
    csv << ["tanaka",20,"tokyo"]
    csv << ["suzuki",25,"osaka"]
end
puts "CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ã¾ã—ãŸã€‚"
#CSV ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§è¡¨ç¤ºã›ã‚ˆã€‚
require "csv"
CSV.foreach("text.csv") do|row|
    puts row.join(",")
end
puts "CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§è¡¨ç¤ºã§ã™ã€‚"
#ä¾‹å¤–å‡¦ç†ã‚’ä½¿ã£ã¦ 0 ã§å‰²ã£ãŸæ™‚ã« "ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ" ã¨è¡¨ç¤ºã›ã‚ˆã€‚
begin
    raise StandardError.new('error')
  rescue => e
    p e.message
  ensure
    p "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿ"
  end
#ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆã«ä¾‹å¤–ã‚’å‡¦ç†ã›ã‚ˆã€‚
begin 
    f=File.open("text.csv","r")
    contet=f.read
rescue Error::ENOENT=>e
    p e.message
    p "ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ã¾ã›ã‚“"
ensure 
    p "å‡¦ç†ã‚’çµ‚äº†ã—ã¾ã—ãŸ"
end

#begin..rescue..end ã‚’ä½¿ã£ãŸã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚’å®Ÿè£…ã›ã‚ˆã€‚
begin
    file=File.open("text.csv","w") 
    file.write("Hello world")
    file.close
rescue =>e
    p e.message
    p "ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ"
ensure 
    file.close if file
end

#ç‹¬è‡ªä¾‹å¤–ã‚¯ãƒ©ã‚¹ã‚’ä½œã£ã¦ã¿ã‚ˆã€‚
class XXXpiTimeException < StandardError
end

#ä¾‹å¤–ã‚’æŠ•ã’ã¦ã¿ã‚ˆã€‚
# ç‹¬è‡ªä¾‹å¤–ã‚¯ãƒ©ã‚¹ã‚’å®šç¾©
class XXXpiTimeException < StandardError
end

# ä¾‹å¤–ã‚’ç™ºç”Ÿã•ã›ã¦ã‚­ãƒ£ãƒƒãƒ
begin
  raise XXXpiTimeException, "ã‚«ã‚¹ã‚¿ãƒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿ!"
rescue XXXpiTimeException => e
  puts "ç‹¬è‡ªä¾‹å¤–ã‚’ã‚­ãƒ£ãƒƒãƒã—ã¾ã—ãŸ: #{e.message}"
end
#ensure ã‚’ä½¿ã£ã¦æœ€å¾Œã«å¿…ãšå®Ÿè¡Œã•ã‚Œã‚‹å‡¦ç†ã‚’ç¢ºèªã›ã‚ˆã€‚
class japan
    def self.run
        puts "èµ°ã‚‹"
    raise 'ã†ãŠãƒ¼'
    puts "ensureã•ã‚Œãªã‹ã£ãŸ"
    ensure 
        puts "ensureã•ã‚Œã¾ã—ãŸ"
    end
end
EnsureRunner.run
#raise ã‚’ä½¿ã£ã¦ã‚¨ãƒ©ãƒ¼ã‚’ç™ºç”Ÿã•ã›ã¦ã¿ã‚ˆã€‚
begin
    japan.run
rescue =>e
    puts "ä¾‹å¤–ã‚’ã‚­ãƒ£ãƒƒãƒã—ã¾ã—ãŸ#{e.message}"
end

#ãƒ•ã‚¡ã‚¤ãƒ«ã«è¤‡æ•°è¡Œã‚’æ›¸ãè¾¼ã¿ã€èª­ã¿è¿”ã›ã€‚
File.opne("text.txt","w") do |f|
    f.puts("hello Ruby")
    f.puts("This is the second line.")
    f.puts("This is the third line.")
end

File.open("text.txt","r") do |f|
    f.each_line do |line|
        puts line
    end
end

#ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå†…ã®ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ã‚’è¡¨ç¤ºã›ã‚ˆã€‚
p Dir.glob("*")
p Dir.glob("./b*")
p Dir.glob("*/")
p Dir.glob("worong")
Dor.glob("b*") {|f|p f}
p f
end
#ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚µã‚¤ã‚ºã‚’å–å¾—ã›ã‚ˆã€‚
File.open("/dev/null") do |f|
    puts f.size
end

#ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ã‘ã€‚
require 'fileutils'
FileUtils.cp('tmp.txt', 'val1.txt')
puts 'ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸã€‚'
#ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤ã™ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ã‘ã€‚
if File.opne("text.txt")
    File.detele("text.txt")
    puts"å‰Šé™¤ã•ã‚Œã¾ã—ãŸ"
else
    puts "ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"
end
81ã€œ100: å¿œç”¨ãƒ»ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
#é…åˆ—ã‚’ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã™ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ã‘ã€‚
s = ["kai", "mai", "hai"]
shuffled = s.shuffle  # é…åˆ—ã‚’ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã—ã¦æ–°ã—ã„é…åˆ—ã‚’è¿”ã™
puts "ãƒ©ãƒ³ãƒ€ãƒ ã«ã•ã‚Œã¾ã—ãŸ: #{shuffled}"
#ãƒãƒ–ãƒ«ã‚½ãƒ¼ãƒˆã‚’å®Ÿè£…ã›ã‚ˆã€‚
def bubble_sort(data)
    length=data.length
    for i in 0..(length-1)
        for j in 1..(length-i-1)
            if data[j-1],data[j]=data[j],data[j-1]
            end
        end
    end
    data
end

#é¸æŠã‚½ãƒ¼ãƒˆã‚’å®Ÿè£…ã›ã‚ˆã€‚
def selection_sort(array)
    n = array.length
    for i in 0..n-1
        min_index=i
        for j in i+1..n
            if array[j] < array [mai_index]
                min_index =j
            end
        end
        array[i],array[min_index] = array[mai_index],array[i] if mai_index !=i
    end
    array
end

arry1=["a","s","e","c","d"]
sorted=selection_sort(ary1)
puts sorted.inspect

#æŒ¿å…¥ã‚½ãƒ¼ãƒˆã‚’å®Ÿè£…ã›ã‚ˆã€‚
class array
    def insert_sort
        inject([]) {|men,val|mem.insert_with_order(val)}
    end
    def insert_with_sort(item)
        pos=find_index{|n|item <=n} ||length
        inspect(pos,itmes)
    end
end

#äºŒåˆ†æ¢ç´¢ã‚’å®Ÿè£…ã›ã‚ˆã€‚
def binary_seach(a,target)
    left,right=0,a,size -1

    while left<= right
        mid=left+(right - left)/2
        
        if a[mid] == target
            return mid
        elsif a[mai]  <target
            left=mid +1
        else
            right=mid -1
        end
        return -1
    end

    arr=[1,2,3,4,5,6]
    puts binary_seach(arr,5)
    puts binary_seach(arr,6)
#å†å¸°ã‚’ä½¿ã£ã¦éšä¹—ã‚’æ±‚ã‚ã‚ˆã€‚
def factorial (n)
    return 1 if n <=1
    n *ã€€factorial(n-1)
end

puts factorial(5)
puts factorial(0)

#å†å¸°ã‚’ä½¿ã£ã¦ãƒ•ã‚£ãƒœãƒŠãƒƒãƒæ•°åˆ—ã‚’æ±‚ã‚ã‚ˆã€‚
def fibonacci(num)
    if num == 0
    0
    elsif num == 1
    1
    else
    fibonacci(num - 1) + fibonacci(num - 2)
    end
end

(0..9).each do |i|
    puts "ç¬¬#{i}é …ï¼š#{fibonacci(i)}"
end
#ãƒãƒƒã‚·ãƒ¥ã‚’ã‚­ãƒ¼ã§ã‚½ãƒ¼ãƒˆã›ã‚ˆã€‚
h={b:2,a:5,c:1}
sorted_by_key=h.sorted_by_key{|key,value| key}
p sorted_by_key.to_s
sorted_by_value=h.sort_by{|key,value| value}
p sorted_by_value.to_h
#ãƒãƒƒã‚·ãƒ¥ã‚’å€¤ã§ã‚½ãƒ¼ãƒˆã›ã‚ˆã€‚
h = { c: -10, z: 10, b: -5, y: 5, a: -1, x: 1 }
sorted=h.sort_by{|key,value|,value}
p sorted.to_h
sortes_desc=h.sort_by{|key,value|,-value}
p sorted_desc.to_h
#å˜èªãƒªã‚¹ãƒˆã‹ã‚‰ã‚¢ãƒŠã‚°ãƒ©ãƒ ã‚’æ¢ã™ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ã‘ã€‚
def anagram?(a,b)
    a.chars.sort==b.chars.sort
end
words=["tex","kar","mama","ext","rak","amam"]
anagrams=[]
world.combination(2) do |a,b|
    anagrams <<[a,b] if anagrams?(a,b)
end
p anagrams
#æš—å·åŒ–ï¼ˆCaesaræš—å·ï¼‰ã‚’å®Ÿè£…ã›ã‚ˆã€‚
def caesar_cipher(str,shift)
    str.chars.map do |char|
        if char =~ /[a-z]/
            (((char.old - 'a'.old + shif)%26)+ 'a'.old).chr
        elsif char =~ /[A~Z]/
            (((char.old - 'A'.old + shift)%26)+ 'A'.old).chr
        else
            char
        end
    end.join
end

plain="attack"
coded=caesar_cipher(plain,3)
decoded= caesar_cipher(coded,-3)

puts "å…ƒã®æ–‡å­—åˆ—:#{plain}"
puts "æš—å·åŒ–: #{coded}"
puts "å¾©å·åŒ–:#{decoded}"
#Caesaræš—å·ã‚’å¾©å·ã›ã‚ˆã€‚
def cipher(start_text,shift,cipher_direction)
    end_text=""
    if cipher_direction == "å¾©å·"
        shift *= -1
    end

    start_text.each_char do |char|
        if char =~ /[a-z]/
            new_char= ((char.old - 'a'.old + shif)%26 + 'a'.old).chr
        end_text += -1
        else
        end_text +=char
        end
    end

    puts "å¤‰æ›çµæœ:#{end_text}"
end

cipher("attck",3,"æš—å·")
cipher("dwwdfn",3,"å¾©å·")
#æ–‡å­—åˆ—ã‚’ãƒãƒƒã‚·ãƒ¥åŒ–ï¼ˆSHA256ï¼‰ã›ã‚ˆã€‚
require 'digest'
text="key=value1"
hash_value = digest::SHA256,hexdigest(text)
puts hash_value
#ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆã›ã‚ˆã€‚
char=[*'A'..'Z',*'a'..'z',*'0'..'9']
password=Array.new(8) {char.sample} .json

puts "ç”Ÿæˆã•ã‚ŒãŸãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰:#{password}"
#å˜èªã‚«ã‚¦ãƒ³ãƒˆãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ã‘ã€‚
text=" foo bar foo buz bar foo"
#ç°¡æ˜“ãƒ­ã‚°ã‚¤ãƒ³èªè¨¼ã‚’å®Ÿè£…ã›ã‚ˆã€‚
require 'digest'
#ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹
USER={
    "john@example.com" => Digest::SHA256.hexdigest("password123")
    "alice@example.con" => Digest::SHA256.hexdigest("alicepass")
}

def login
    printã€€"ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹"
    email=gets.chomp

    print "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰"
    passworld=gets.chomp

    if USER.key?(email)
        hashed = Digest::SHA256.hexdigest(password)#ã‚·ãƒ¼ã‚¶ãƒ¼æš—å·
        if USER[email] == hashed
            puts "âœ…ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸ!ã‚ˆã†ã“ã#{email}ã•ã‚“!"
        else
            puts "âŒãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒä¸€è‡´ã—ã¾ã›ã‚“"
        end
        else
            puts "âŒãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå­˜åœ¨ã—ã¾ã›ã‚“"
        end
    end

    puts "=== Ruby ãƒ­ã‚°ã‚¤ãƒ³èªè¨¼==="
    login

#ãƒ©ãƒ³ãƒ€ãƒ ãªã‚»ãƒƒã‚·ãƒ§ãƒ³IDã‚’ç”Ÿæˆã›ã‚ˆã€‚
require 'sesion'
seesion_id=SecureRandom.hex(16)#16ãƒã‚¤ãƒˆ->32æ¡
puts seesion_id
#ç°¡æ˜“æ²ç¤ºæ¿ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ä½œã‚Œã€‚
class Keiziban
    def initialize
        @posts=[]
    end

    #æŠ•ç¨¿ã‚’è¿½åŠ 
    def post(username,message)
        @posts << {user: username,message: message}
    end

    #å…¨ã¦ã®æŠ•ç¨¿ã‚’è¡¨ç¤º
    def show_posts
        puts === æ²ç¤ºæ¿ ===
        @posts.each_with_index do |post,i|
            puts "#{i + 1}.#{post[:user]}:#{post[:username]}"
        end
    end
end

board =Keiziban.new
board.post("ã‚¸ãƒ§ãƒ³"ã€"ã“ã‚“ã«ã¡ã¯!")
board.post("ã‚¢ãƒªã‚¹","ãŠã¯ã‚ˆã†ã”ã–ã„ã¾ã™")
board/show_posts
#Todoãƒªã‚¹ãƒˆãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ä½œã‚Œã€‚
class Todo
    def initialize
        @todos=[]
    end

    def add(task)
        @todos << task
        puts "âœ…è¿½åŠ ã—ã¾ã—ãŸã€‚"
    end

    def show
        puts "===  Todoãƒªã‚¹ãƒˆ==="
        if @todos.empty?
            puts "(ä½•ã‚‚ç™»éŒ²ã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚)"
        else
            @todos.each_with_index do |task,i|
                puts "#{i + 1}.#{task}"
            end
        end
    end
end
#ã‚¿ãƒ¼ãƒŸãƒŠãƒ«
todo=Todo.new
todo.add("Rubyå‹‰å¼·ã™ã‚‹")
todo.show
#é›»å“ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ä½œã‚Œã€‚
def evaluate(tree)
    op =tree[0]
    case op
    when "lit"
        tree[1]
    when "+","-","*","/"
        left =evaluate(tree[1])
        right=evaluate(tree[2])
        last.send(op,right)
    else
        raise "æœªçŸ¥ã®æ¼”ç®—å­#{op}"
    end
end

tree=[["*",["+",]["lit",2],["list",3]],["-",["list",4],["list",1]]]
puts evaluate(tree)
#ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¯ãƒ©ã‚¹ï¼ˆåˆæœŸåŒ–ï¼‰
class  User
    attr_reader :name
    def initialize(name,password)
      @name=name
      @password=password
    end
  
    def info 
      "User:#{@name}"
    end
  end
  
  u=User.new("alice","secret")
  puts u.info
  
  #ãƒ­ã‚°ã‚¤ãƒ³ãƒ¡ã‚½ãƒƒãƒ‰
  class User
    def login(input_password)
      if input_password == @password
        "ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸ"
      else
        "ãƒ­ã‚°ã‚¤ãƒ³å¤±æ•—"
      end
    end
  end
  
  u=User.new("bob","pw123")
  puts u.login("pw123")
  puts u.login("bob")
  #è„†å¼±ãªèªè¨¼ä¾‹
  class User
    def login(input_password)
      @password.include?(input_password)
      "ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸ(å¼±ç‚¹)"
      else
        "ãƒ­ã‚°ã‚¤ãƒ³å¤±æ•—"
      end
    end
  end
  
  u=User.new("admin","adimin123")
  puts u.insecure_login("ad")
  
  #ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ SHA-256
  require 'digest'
  require 'securerandom'
  
  class User
    attr_reader :name,:salt,:pw_hash
    def initialize(name,plain_password)
      @name=name
      @salt=SecureRandom.hex(16)
      @pw_hash=self.class.hash_password(plain_password,@salt)
    end
  
    def self.hash_password(password,salt)
      Dight::SHA256.hexdigest(salt+password)
    end
  
    def login(input_password)
      hashed=self.class.hash_password(input_password,@salt)
      if hashed == @pw_hash
        "ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸ"
        else
          "ãƒ­ã‚°ã‚¤ãƒ³å¤±æ•—"
        end
      end
    end
  
    u=User.new("alice","String0!")
    puts u.login("String!")
    puts u.login("Wrong")
  
  #è¾æ›¸æ”»æ’ƒã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
  class Cracker
    def initialize(hash_func,salt)
      @hash=hash_func
      @salt=salt
    end
  
    def brute_force(target_hash,wordlist)
      wordlist.each do |word|
        attemt=@hash_func.call(wold,@salt)
        return wold if attemt == target_hash
      end
      nil
    end
  end
  
  hash_fn=proc{|pw,salt| Dight::SHA256.hexdigest(salt+pw)}
  salt="abcd1234"
  target_hash=hash_fn.call("password123",salt)
  crecker =Cracker.new(hash_fn,salt)
  puts crecker.brute_force(target_hash,["123","passprd","password123","admin"])
  
  #æ¨©é™ç®¡ç†
  class admin < User
    def delete_user(target_user)
      #ç°¡æ˜“çš„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã€€å®Ÿéš›ã¯DBæ“ä½œ
      "ãƒ¦ãƒ¼ã‚¶ãƒ¼#{target_user.name}ã‚’å‰Šé™¤ã—ã¾ã—ãŸ"
    end
  end
  
  admin =Admin.new("root","rootpy")
  user=User.new("gusst","gpass")
  puts admin.delete_user(user)
  
  #ãƒ­ã‚°ã®è¨˜éŒ²
  class SimpleLogger
    def initialize(path="security_log.txt")
      @path=path
    end
  
    def log(message)
      Flie.open(@path,"a") do |f|
        f.puts ("[#{Time.now.iso8601}]#{message}")
      end
    end
  end
  
  logger=SimpleLogger
  logger.log("LOGIN_FAILED user=alice ip=127.0.0.1")
  logger.log("LOGIN_SUCCESS user=bob ip=127.0.0.1")
  
  #CSRFå¯¾ç­–ãƒˆãƒ¼ã‚¯ãƒ³
  require 'securerandom'
  class Session
    def initialize
      @tokens={}
    end
  
    def create_session(user)
      sid=SecureRandom.hex(16)
      @tokens[sid]=SecureRandom.hex(16)
      {Session_id: sid,token: @token[sid]}
    end
  
    def valid_tokein?(Session_id,token)
      @tokens[Session_id] && @tokens[Session_id] == token
    end
  end
  
  s=Session.new
  sess = s.create_session("alice")
  puts sess
  puts s.valid_tokein?(sess[:Session_id],sess[:token])
  puts s.valid_tokein?(sess[:Session_id],"bod")
  
  #SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³ã®å†ç¾
  require 'sqlite3'
  
  DB=SQLLite3::DataBase.new(":memory:")
  DB.execute("CREATE TABLE users(id INTEGER PRIMARY KEY,name TEXT,pw TEXT)")
  BD.execute("INSERT INTO users (name, pw) VALUES (?,?)",["alice","hash1"])
  
  def valnerable_search(name) #å¼±ç‚¹æ¤œç´¢
    sql="SELECT * FROM users WHERE name ='#{name}'"
    DB.execute(sql)
  end
  
  def safe_search(name)
    DB.execute("SELECT * FROM users WHERE name =?",[name])
  end
  
  puts "å¼±ç‚¹:"
  p valnerable_search("alice")
  p valnerable_search("x'OR'1'='1")
  
  putsã€€"å®‰å…¨:"
  p safe_search("alice")
  p safe_search("x' OR '1'=1")
  
  #ãƒ­ã‚°ã‚¤ãƒ³è©¦è¡Œåˆ¶é™
  class LoginManager
    def initialize(max_failures=3)
      @failures=Hash.new(0)
      @locked={}
      @max=max_failures
    end
  
    def record_failure(username)
      return if @locked[username]
      @failures[username] +=1
      if @failures[username] >= @max
        @locked[username] =true
      end
    end
  
    def locked?(username)
      !!@locked[username]
    end
  
    def reset(username)
      @failures.delete(username)
      @locked.delete(username)
    end
  end
  
  lm=LoginManager.new(3)
  lm.record_failure("alice")
  lm.record_failure("alice")
  lm.record_failure("alice")
  puts lm.locked?("alice")
  
  #æ•™è‚²ç”¨ï¼šRuby ã§ã®è¾æ›¸æ”»æ’ƒï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ãƒãƒƒã‚·ãƒ¥ã«å¯¾ã™ã‚‹ç…§åˆï¼‰
  # dict_attack.rb
  # æ•™è‚²ç”¨ã‚µãƒ³ãƒ—ãƒ«ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ã®ãƒãƒƒã‚·ãƒ¥ã«å¯¾ã™ã‚‹è¾æ›¸ç…§åˆï¼‰
  # å®Ÿè¡Œå‰ã«å¿…ãšè‡ªå·±ç’°å¢ƒã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã™ã‚‹ã“ã¨ï¼
  
  require 'digest'
  require 'time'
  
  # --- è¨­å®šï¼ˆæ•™è‚²ç”¨ï¼‰ ---
  # æœ¬æ¥ã¯ DB ç­‰ã«ä¿å­˜ã•ã‚Œã¦ã„ã‚‹ã€Œã‚½ãƒ«ãƒˆä»˜ããƒãƒƒã‚·ãƒ¥ã€ã‚’æƒ³å®š
  salt="a1b2c3d4e5f6"   # ä¿å­˜ã•ã‚Œã¦ã„ã‚‹ã‚½ãƒ«ãƒˆï¼ˆä¾‹ï¼‰
  target_plain="secret123"# æœ¬æ¥ã¯ä¸æ˜ã€‚ã“ã“ã§ã¯æ¨¡æ“¬å¯¾è±¡ã¨ã—ã¦è¨­å®š
  target_hash=Dight::SHA256.hexdigest(salt+ target_plain)# ç›®æ¨™ãƒãƒƒã‚·ãƒ¥ï¼ˆæ”»æ’ƒå¯¾è±¡ã®ãƒãƒƒã‚·ãƒ¥ï¼‰
  # å°ã•ã‚ã®è¾æ›¸ï¼ˆå®Ÿé‹ç”¨ã®è¾æ›¸ã¯ã‚‚ã£ã¨å¤§ãã„ï¼‰
  wordlist=["123","password","admin","secret","secret123","letmin"]
  
  puts "ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒãƒƒã‚·ãƒ¥:#{target_hash}"
  puts "è¾æ›¸ã‚µã‚¤ã‚º:#{wordlist.size}"
  puts "é–‹å§‹:#{Time.now.iso8601}"
  
  found=nil
  start_time=Time.now
  
  wordlist.each_with_index do |word,idx|
  # ãƒãƒƒã‚·ãƒ¥åŒ–ï¼ˆã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¨åŒã˜æ–¹å¼ã§ï¼‰
    attempt_hash=Digest::SHA256.hexdigest(salt + word)
    # ãƒ­ã‚°å‡ºåŠ›ï¼ˆå­¦ç¿’ç”¨ã€‚å®Ÿé‹ç”¨ã§ã¯ãƒ­ã‚°ã«å¹³æ–‡ã‚’æ›¸ã‹ãªã„ï¼‰
    puts "[#{idx+1}/#{wordlist.size}]è©¦è¡Œ:#{wold}->#{attempt_hash}"
  
    if attempt_hash == target_hash
      found=word
      puts "=== è§£èª­æˆåŠŸ ==="
      puts "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ #{found}"
      break
    end
  end
  
  elapsed=Time.now - start_time
  if found 
    puts "è¦‹ã¤ã‹ã‚‹ã¾ã§ã®æ™‚é–“:#{elapsed.round(3)}ç§’"
  else
    puts "è¾æ›¸å†…ã«è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ(æ‰€è¦æ™‚é–“:#{elapsed.round(3)})ç§’"
  end
  
  #ãƒ­ã‚°ã‚¤ãƒ³å¤±æ•—ã®è¨˜éŒ²ï¼ˆâ˜…ï¼‰
  require 'logger'
  logger = Logger.new(STDOUT)
  logger.info("ãƒ­ã‚°ã®é–‹å§‹")
  username="test_user"
  logger.warn("ãƒ­ã‚°ã®å¤±æ•—:ãƒ¦ãƒ¼ã‚¶-å=#{username}")
  
  #å¹³æ–‡ä¿å­˜ã®å±é™ºã‚’ç†è§£ã—ã¦ãƒãƒƒã‚·ãƒ¥åŒ–ã‚’å®Ÿè£…ã™ã‚‹ã€‚
  class User < ApplicationRecord
    has_secure_password
  end
  
  #å¹³æ–‡ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ä¿å­˜
  require 'bcrypt'
  class PasswordManager
    # ã“ã“ã§ã¯ç°¡æ˜“çš„ã« Hash ã‚’ "DBã®ä»£ã‚ã‚Š" ã«ä½¿ã£ã¦ã„ã¾ã™ã€‚
    # å®Ÿé‹ç”¨ã§ã¯ DB (usersãƒ†ãƒ¼ãƒ–ãƒ«ã® password_digest ã‚«ãƒ©ãƒ ç­‰) ã«ä¿å­˜ã—ã¦ãã ã•ã„ã€‚
    def initialize
      @store={}
    end
    # ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ç™»éŒ²ï¼ˆãƒãƒƒã‚·ãƒ¥åŒ–ã—ã¦ä¿å­˜ï¼‰
    def set_password(username,plain_password, cost: BCrypt:: Engine::DEFAULT_COST)
      # cost ã‚’ä¸Šã’ã‚‹ã¨å¼·åº¦ã¯ä¸ŠãŒã‚‹ãŒå‡¦ç†æ™‚é–“ã‚‚å¢—ãˆã‚‹ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ååˆ†ï¼‰
      hash =BCrypt::Password.create(plain_password, cost: cost)
      @store[username] =hash.to_s
      true
    end
    # èªè¨¼ï¼ˆä¿å­˜ã—ãŸãƒãƒƒã‚·ãƒ¥ã¨ç…§åˆï¼‰
    def authenticate(username,plain_password)
      hashed=@store[username]
      return false unless hashed
      # BCrypt::Password#== ã¯å®‰å…¨ã«æ¯”è¼ƒã™ã‚‹å®Ÿè£…ã«ãªã£ã¦ã„ã‚‹
      BCrypt::Password.new(hashed) == plain_password
    end
    # (è£œåŠ©) DBã‹ã‚‰ãƒãƒƒã‚·ãƒ¥ã‚’èª­ã¿å‡ºã™ã‚µãƒ³ãƒ—ãƒ« getter
    def get_hash(username)
      @store[username]
    end
  end
  
  # ä½¿ç”¨ä¾‹
  pm = PasswordManager.new
  pm.set_password('alice', 'S3cret!')
  puts pm.authenticate('alice', 'S3cret!') # => true
  puts pm.authenticate('alice', 'wrong')   # => false
  
  #ğŸ”â‘¤ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ»Webç³»ï¼ˆSinatra/Railsãªã©ï¼‰
  #Sinatraã‚’ä½¿ã£ã¦ã€ŒHello, worldã€ã‚’è¡¨ç¤ºã™ã‚‹æœ€å°ã®Webã‚¢ãƒ—ãƒªã‚’ä½œã‚Œã€‚
  require 'sinatra'
  get '/'do
    "hello world!"
  end
  #/hello/:name ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ãŸã‚‰ã€ŒHello, name!ã€ã¨è¡¨ç¤ºã™ã‚‹ãƒ«ãƒ¼ãƒˆã‚’ä½œã‚Œã€‚
  require 'sinatra'
  get '/hello/:name'do
    name=params[:name]
    "hello,#{name}!"
  end
  #ãƒ•ã‚©ãƒ¼ãƒ ã§é€ä¿¡ã•ã‚ŒãŸåå‰ã‚’å—ã‘å–ã‚Šã€ç”»é¢ã«è¡¨ç¤ºã™ã‚‹ã‚¢ãƒ—ãƒªã‚’ä½œã‚Œã€‚
  require 'sinatra'
  # ãƒ•ã‚©ãƒ¼ãƒ ã‚’è¡¨ç¤º
  get '/' do
    <<-HTML
    <form action="/hello " method="post">
    åå‰: <input type="text" name="name">
    <input type="submit" value="é€ä¿¡">
    </form>
    HTML
  end
  # ãƒ•ã‚©ãƒ¼ãƒ é€ä¿¡ã‚’å—ã‘å–ã‚‹
  post '/hello' do
    name=params[:name]
    "hello #{name}!"
  end
  
  #SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³ã‚’é˜²ããŸã‚ã®ActiveRecordã§ã®æ›¸ãæ–¹ã‚’èª¿ã¹ã€ä¾‹ã‚’æ›¸ã‘ã€‚
  class BooksController < ApplicationRecord
    def index
      if params[:title].present?
        pattern = "%#{ActiveRecord::Base.sanitize_sql_like(params[:title])}%"
        @books=Book.where("title LIKE ?",pattern)
      else
        @books=Book.all
      end
  
      # å‹•çš„ã‚½ãƒ¼ãƒˆã¯ãƒ›ãƒ¯ã‚¤ãƒˆãƒªã‚¹ãƒˆã‚’ä½¿ã†
      allwowed_sort= %w[title created_at author]
      sort= allwowed_sort.include?(params[:sort])? params[:sort]:"created_at"
      dir= %w[asc desc].include?(params[:sort])?params[:sort]:"asc"
      @books=@books.order("#{sort}#{dir}")
      
      render json: @books
    end
  
    def create
      @book=Book.new(book_params)
      if @book.save
        render json: @book, status: :create
      else
        render json: @book.errors, status: :unprocessable_entity
      end
    end
  
    private
  
    def book_params
      params.require(:book).permit(:title,:author)
    end
  end
  
  #Railsã®before_actionã‚’ä½¿ã£ã¦ãƒ­ã‚°ã‚¤ãƒ³ãƒã‚§ãƒƒã‚¯ã‚’è¡Œã†ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã‘ã€‚
  class BooksController < ApplicationRecord
     # index ã¨ show ã¯ãƒ­ã‚°ã‚¤ãƒ³ä¸è¦ã€ãã‚Œä»¥å¤–ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã¯ãƒ­ã‚°ã‚¤ãƒ³å¿…é ˆ
    before_action :authenticate_user!,except: [:index,:show]
    def index
      @books = Book.all
    end
  
    def show
      @book = Book.find(params[:id])
    end
  
    def new
      @book=Book.new
    end
  
    def create
      @book=Book.new(book_params)
      if @book.save
        redirect_to @book,notice: 'ä½œæˆã—ã¾ã—ãŸ'
      else
        render :new
      end
    end
  
    # ä»–ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆedit, update, destroyãªã©ï¼‰
    private
    # Strong Parameters
    def book_params
      params.require(:book).permit(:title, :author)
    end
    # ãƒ­ã‚°ã‚¤ãƒ³ãƒã‚§ãƒƒã‚¯
    def authenticate_user!
      unless current_user
        redirect_to login_path, alert: 'ãƒ­ã‚°ã‚¤ãƒ³ãŒå¿…è¦ã§ã™ã€‚'
      end
    end
    # current_user ãƒ¡ã‚½ãƒƒãƒ‰ã¯é€šå¸¸ ApplicationController ã«å®šç¾©
    # ä¾‹: ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‹ã‚‰ãƒ¦ãƒ¼ã‚¶æƒ…å ±ã‚’å–å¾—
    # def current_user
    #   @current_user ||= User.find_by(id: session[:user_id])
    # end
  end
  
  #Cookieã«ä¿å­˜ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ãƒ»è¡¨ç¤ºã™ã‚‹Sinatraã‚¢ãƒ—ãƒªã‚’æ›¸ã‘ã€‚
  require 'sinatra'
  #ã“ã“ã¯ãƒ›ãƒ¼ãƒ é€ä¿¡
  get '/' do
    <<-HTML
    <form action="/set" method="post">
      åå‰: <input type="text" name="name">
      <input type="submit" value="ä¿å­˜">
    </form>
    HTML
  end
  # Cookieã«å€¤ã‚’ä¿å­˜
  post '/show' do
    name=require.cookies["name"]
    if name
      "Cokieã®å€¤:#{name}"
    else
      "Cookieã¯ã¾ã è¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“"
    end
  end
  
  #ç°¡æ˜“çš„ãªã€Œãƒãƒ¼ãƒˆç›£è¦–ãƒ­ã‚°ã€ã‚’Sinatraã§è¡¨ç¤ºã™ã‚‹ä»•çµ„ã¿ã‚’ä½œã‚Œã€‚
  require 'sinatra'
  require 'time'
  require 'erb'
  require 'rack/Utils'
  
  LOG_DIR=File.expand_path("./logs",__dir__)
  LOG_FILE=File.json(LOG_DIR,"port_monitor.log")
  # ãƒ­ã‚°ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªï¼ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æº–å‚™
  Dir.mkdir(LOG_DIR) unless Dir.exist?(LOG_DIR)
  File.write(LOG_FILE,"") unless File.exist?(LOG_FILE)
  
  helprs do 
    def h(text)
      Rack::Utils.escape_html(text.to_s)
    end
  
    # ãƒ­ã‚°ã‚’ãƒ‘ãƒ¼ã‚¹ã—ã¦é…åˆ—ã§è¿”ã™ï¼ˆæœ€æ–°ãŒå…ˆé ­ï¼‰
    def read_logs 
      line=[]
      File.open(LOG_FILE,"r") do |f|
        f.each_line do |line|
          # æœŸå¾…ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ: "2025-10-20T21:00:00Z | 192.168.0.10 | 22 | UP | note"
          lines << line.chomp
        end
      end
      lines.reverse
    end
  end
  
  # ãƒ«ãƒ¼ãƒˆï¼šãƒ­ã‚°è¡¨ç¤º + è¿½åŠ ãƒ•ã‚©ãƒ¼ãƒ 
  get '/' do 
    @logs=read_logs
    erb :index
  end
  # ãƒ•ã‚©ãƒ¼ãƒ ã‹ã‚‰ã®ãƒ­ã‚°è¿½åŠ 
  post '/log' do 
    host=params[:host].to_s.strip
    port=params[:port].to_s.strip
    statu=params[:statu].to_s.strip.update
    note=params[:note].to_s.strip
  # ç°¡æ˜“ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
    if host.empty? || port.empty? || !(port =~ /^\d+$/) || !%w[UP DOWN TIMEOUT].include?(status)
      redirect to("?/error=invalid")
    end
  
    timestamp=Time.now.utc.iso8601
    entry="#{timestamp} | #{host} | #{port} | #{status} | #{note}\n"
     # ãƒ•ã‚¡ã‚¤ãƒ«è¿½è¨˜ï¼ˆæ’ä»–ãƒ­ãƒƒã‚¯ï¼‰
     File.opne(LOG_FILE,"a") do|f|
      f.flock(File::LOCK_EX)
      f.write(entry)
      f.flock(File::LOCK_UI)
     end
  
     redirect to ("/")
    end
  
    __END__
  
  @@ index
  <!doctype html>
  <html>
  <head>
    <meta charset="utf-8">
    <title>ç°¡æ˜“ãƒãƒ¼ãƒˆç›£è¦–ãƒ­ã‚°</title>
    <style>
      body { font-family: sans-serif; margin: 20px; }
      table { border-collapse: collapse; width: 100%; }
      th, td { border: 1px solid #ccc; padding: 6px 8px; text-align: left; }
      th { background: #f4f4f4; }
      form { margin-top: 16px; }
      .error { color: red; }
    </style>
  </head>
  <body>
    <h1>ç°¡æ˜“ãƒãƒ¼ãƒˆç›£è¦–ãƒ­ã‚°</h1>
  
    <% if params['error'] == 'invalid' %>
      <p class="error">å…¥åŠ›ã«ä¸å‚™ãŒã‚ã‚Šã¾ã™ã€‚host, numeric port, status(UP|DOWN|TIMEOUT) ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚</p>
    <% end %>
  
    <h2>æœ€æ–°ãƒ­ã‚°ï¼ˆä¸ŠãŒæ–°ã—ã„ï¼‰</h2>
    <table>
      <tr><th>æ™‚åˆ»(UTC)</th><th>ãƒ›ã‚¹ãƒˆ</th><th>ãƒãƒ¼ãƒˆ</th><th>çŠ¶æ…‹</th><th>ãƒ¡ãƒ¢</th></tr>
      <% @logs.each do |line| %>
        <% parts = line.split('|').map(&:strip) %>
        <tr>
          <td><%= h(parts[0]) %></td>
          <td><%= h(parts[1]) %></td>
          <td><%= h(parts[2]) %></td>
          <td><%= h(parts[3]) %></td>
          <td><%= h(parts[4]) %></td>
        </tr>
      <% end %>
    </table>
  
    <h2>ãƒ­ã‚°ã‚’æ‰‹å‹•è¿½åŠ </h2>
    <form action="/log" method="post">
      <label>Host: <input type="text" name="host" placeholder="192.168.0.10"></label><br>
      <label>Port: <input type="text" name="port" placeholder="22"></label><br>
      <label>Status:
        <select name="status">
          <option>UP</option>
          <option>DOWN</option>
          <option>TIMEOUT</option>
        </select>
      </label><br>
      <label>Note: <input type="text" name="note" placeholder="optional"></label><br>
      <input type="submit" value="è¿½åŠ ">
    </form>
  
    <p><a href="/raw" target="_blank">ç”Ÿãƒ­ã‚°ã‚’è¡¨ç¤º(/raw)</a></p>
  </body>
  </html>
  
  module  SafeModules
    class HelloModule
    def initialize 
      @name=opts[:name] || "ä¸–ç•Œ"
    end
    
    def run 
      puts "hell, #{@name} "
    end
  end
  
  #å•1 â€” ã‚¯ãƒ©ã‚¹ / ç¶™æ‰¿
  class ModuleBeae
    def name
      self.class.name
    end
  
    def run 
      raise NoImplementedErrorr,"subclass must implement run"
    end
  end
  
  class ModA< ModuleBeae
    def run;  "runA";end
  end
  
  class ModB < ModuleBeae
    def run; "runB";end
  end
  
  #å•2 â€” ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« mixin ã¨ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰
  require 'time'
  module timestampable
    def initialize
      @log=[]
    end
  
    def log(message)
      timestamp=Time.now.iso8601
      @log << "[#{timestamp} #{message}]"
    end
  
    def show_log
      @log.each {|entry| puts entry}
    end
  end
  
  class ApplicationController
    initialize LoggerMixin
  
    def initialize
      initialize_logger
    end

    def perform_action(action_name)
    log("Action #{action_name} started")
    #ã“ã“ã«ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†ã‚’ç½®ã
    log("Action #{action_name} completed")
    end
end

app=ApplicationController.new
app.perform_action("test_action")
app.show_log

#Ruby Silverè©¦é¨“ æ–‡ç« å•é¡Œ100å•
#å¤‰æ•°ã¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç†è§£
y=5
x=y
p x

#ã‚·ãƒ³ãƒœãƒ«ã¨æ–‡å­—åˆ—ã®é•ã„
str="hello"
aym=hello: :world
p str.object_id
p sym.object_id

arr=[1,2,3,4]
arr[1..2] = [9,9,9]
p arr

def greet(name="Guest")
  "hello ,#{name}!"
end

puts greet
puts greet("Ruby")

def ass(a,b)
  return a + b
  a*b
end

p add(2,3)

class User
  attr_accesssor :name
  def initialize(name)
    @name=name
  end
end

u=User.new("Ruby")
puts u.name
u.name="Bob"
puts u.name

class Counter
  @@counr=0
  def initialize
    @@count +=1
  end
  def self.count
    @@count
  end
end

3.times{Counter.new}
puts Counter.count

module Walkable
  def Walk
    "Walking"
  end

  class Person
    include Walkable
  end

  p = Preson.new
  puts p.Walk

  numbers=[1,2,3,4]
  sum=0
  numbers.each { |n|n*2}
  puts sum

  p [1,2,3].map {n|n*2}

  begin
    1/0
  rescue ZeroDivisionError =>e
    puts "Error:#{e.class}"
  ensure
    puts "Done"
  end

  Fele.open("test.txt","w") do |f|
    f.puts "hello "
  end

  pr=Proc.new{|x|x*2}
  puts pr.call(3)

  lam=->(x){x*3}
  puts lam.call(3)

  class example
    def public_method
      private_metthod
    end

    private
    def private_metthod
      puts "Called private"
    end
  end

  e=Example.new
  e.public_method

class MyClass
  def self.greet
    "Hello"
  end
end

puts MyClass.greet

def order(item:,quantity: 1)
  "#{quantity}of #{item}"
end

puts order(item:"Apple")
puts order(item:"banana",quantity: 5)

t1=Time.new
t2=Time.new(20225,1,1)
puts t1
puts t2

h={a: 1,b: 2,c: 3}
h.each (|k,v|puts "#{k}=>#{v}")

s1="hello"
s2=s1+"world"
s1<<"!"
puts s1
puts s2

class Example
  @@class_var=0
  def initialize
    @instance_var=1
  end
end
#extend ã®ä¾‹
module Greetings
  def greet
    "Hi"
  end
end

class Preson; end
p=Person.new
p.extend(Greetings)
puts p.greet

#ä¾‹å¤–ã‚’æ•æ‰ã—ã€finallyçš„å‡¦ç†ï¼ˆensureï¼‰ã‚’è¡Œã†ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã‘
begin
  num = 10/0
  rescue ZeroDivisionError => e
    puts "Reeoe: #{e.message}"
    ensure
      puts "å‡¦ç†ã¯çµ‚äº†ã—ã¾ã—ãŸã€‚"
    end

    File.open ("sample.txt","w") do |file|
      file.puts "Hello,Ruby!"
    end

    File.opne("sample.txt","r")vdo |file|
    puts file.read
  end

  module greet
    def hello "hello!"
    end
  end

  class User
    include Greet
  end

  puts User.new.hello

  module MathTool
    def double(x)
      x*2
    end
  end
  
  class Calc
    extend MathToolend

puts Calc.double(5)

class Counter
  @@count=0
  def initialize
    @@count +=1
  end

  def self.count
    @@count
  end
end

3.times{Counter.new}
puts Counter.count

class Preson
  attr_reader :name
  attr_reader :age
  attr_accessor :email

  def initialize(name)
    @name=name
  end
end

class numbers
  include Enumerable
  def initialize(nums)
    @nums=nums
  end

  def each 
    @nums.each{|n| yield n}
  end
end
nums=Numbers.new([1,2,3])
puts nums.map{|n| n*2}

def exec_proc(pr,value)
  pr.call(value)
end
p=Proc.new{|x|x*3}
puts exec_proc(p,4)

def triple_lambda
  ->(x) {x*3}
end

lam=triple_lambda
puts lam.call(5)

def test_oproc
  p=Proc.new{return "Proc!"}
  p.call
  "ã“ã“ã¯æ¥ã‚‹ãª"
end

def test_lambda
  l =->{return "lambda!"}
  l.call
  "ã“ã“ã«æ¥ã‚‹"
end

puts test_proc
puts test_lambda

hash={a:1,b:2,c:3}
hash.each do |key,value|
  puts "#{key} = #{value}"
end

arr=[1,2,3,4,5,6]
even=arr.select{|n|n.even?}
puts even.inspect

srr=[1,2,3]
doubles = arr.map{|n|n*2}
puts doubled.inspect

sum =[1,2,3].reduce(o) {|acc,n| acc +n}
puts sum

class item
  def self.info
    "Item calss"
  end

  def name
    "item_name"
  end
end

class MyError < StandardError; end
def ckeck_number(n)
  raise MyError,"è² ã®æ•°ã¯ä¸å¯"ã€€if n <0
end

chak_number(-1) rescue puts "Error!"

nuw=Time.new
puts nuw.strftime("%Y/%m/%d %H:%M:%S")


def user_info(name:,age:)
  "#{name} is #{age} years old."
end

puts user_info(name:"Taro",age:25)

def greet(name="Guest")
  "Hello,#{name}!"
end
puts greet
puts greet("Bob")

str="I like dog."
puts str.gsub("dog","cat")

words="apple,banana,cherry".split(",")
puts words.inspect

sym=:hello
puts sym.to_s
puts "hello".to_sym

arr=[1,2,3,4,5]
arr << 4
puts arr.inspect

arr=[1,2,3]
arr.unshift(1)
puts arr.inspect

arr=[1, 2, 2, 3, 3]
puts arr.uniq.inspect

h={a:1,b:2,c:3}
puts h.keys.inspect

h={x:10,y:20}
puts h.values.inspect

text=" I lave Ruby"
puts "å«ã¾ã‚Œã‚‹"ã€€if text =~ /Ruby/

str="1234"
puts "æ•°å€¤ã§ã™" if str =~ /^\d+$/

puts "ãƒãƒƒãƒ"ã€€if "abcgf" =~ /^abc/

class Animal
  def sound
    "generic sound"
  end
end

class Dog < Animal
  def sound
    supre + "+brak"
  end
end

puts Dog.new.sound

class User
  def initialize(name)
    @name=name
  end
end

class Admin < User
  def initialize(name,role)
    supre(name)
    @role=role
  end
end

class Base
  def greet
    "Hello"
  end
end

class Chid < Base
  def greet
    super + ",world!"
  end
end

puts Chaid.new.greet

module Greet
  def hello
  "hello"
  end
end

class User
  include Greet
  def hello
    super + ",User!"
  end
end

puts User.new.hello

module A
  def hi 
    "form modeule A"
  end
end

class B
  prepend A
  def hi
    "from class B"
  end
end

puts .B.new.hi

def repeat
  yield
  yield
end

repeat {puts "Hello!"}

def greet(&block)
puts "Start"
block.call
puts "End"
end

greet {puts "hello Block!"}

def each_item(arr)
  arr.each {|item| yield item}
end

each_item([1,2,3]) {|x| puts x**2}

def exec_twice(pr)
  pr.call
  pr.call
end

my_proc=Proc.new{ puts "Run!"}
exec_twice(my_proc)

class Counter
  @@count=0
  def initialize
    @@count +=1
  end
  def self.total
    @@count
  end
end

3.item {Counter.new}
puts Counter.total

class Item
  def self.category
    "General"
  end
  def name
    "No name"
  end
end

puts Item.category
puts Item.new.name

class User
  attr_reader :name
end

u=User.new
u.name="Alice"
puts u.name

class Product
  atter_reder :name, :prics
  def initialize(name,price)
    @name=name
    @price=price
  end
end

item=Product.new("Pen",100)
puts "#{item.name}:#{item.price}å††"

class Animal
  def speak
    "___"
  end
end

class Cat < Animal
  def speak
    "Meow"
  end
end

puts Cat.new.speak

class Base
  def greet
    "Hello"
  end
end

class Chaid < Base
  def greet
    super + ",world!"
  end
end

puts Chaid.new.greet

module Greet
  def hello
    "HI"
  end
end

class User
  include Greet
end

puts User.new.hello

module Greet
  def hello
    "hello!"
  end
end

class Person
  extend Greet
end

puts Person.hello

begin
  10 /0
  rescue ZeroDivisionError => e
    puts "ã‚¼ãƒ­ãŒã§ã¯å‰²ã‚Šåˆ‡ã‚Œã¾ã›ã‚“"
  end

begin
  raise "ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ"
rescue
  puts "æ•æ‰ã—ã¾ã—ãŸ" 
rescue
  puts "å¿…ãšå®Ÿè¡Œã•ã‚Œã¾ã™"
end

class MyError < StandardError; end

begin
  raise MyError, "ã‚«ã‚¹ã‚¿ãƒ ã‚¨ãƒ©ãƒ¼"
rescue MyError => e
  puts e.message
end

begin
  begin
    raise "å•é¡Œã‚¨ãƒ©ãƒ¼"
    rescue
      puts "å‡¦ç†ã‚¨ãƒ©ãƒ¼"
      raise 
    end
    rescue
      puts "ä¸Šä½"
    end

begin
  10/0
  rescue ZeroDivisionError => e
    puts "ã‚¼ãƒ­é™¤ç®—"
  rescue TypeError => e
    puts "å‹ã‚¨ãƒ©ãƒ¼"
  end

def divide(a,b)
  a / b
rescue ZeroDivisionError
  "ã‚¼ãƒ­ã§å‰²ã‚Šåˆ‡ã‚Œã¾ã™"
end

puts divide(10,0)

begin
  1 / 0
rescue ZeroDivisionError => e
  puts e.close
  puts e.message
end

raise RuntimeError, "ä½•ãŒèµ·ããŸ!?"

begin
  puts "æ­£å¸¸"
rescue
  puts "ã‚¨ãƒ©ãƒ¼æ™‚"
rescue
  puts "ã‚¨ãƒ©ãƒ¼ãŒãªã‘ã‚Œã°å®Ÿè¡Œ"
end

begin 
  10/0
rescue
end
puts "ç¶šè¡Œ"

begin
  1/ 0
rescue =>e
  File.open("erro.log","a") { | f | f.puts e.message}
end

def risky
  raise "å¤±æ•—"
rescue
  "ãƒªãƒˆãƒ©ã‚¤å¯èƒ½"
end

puts risky

user =User.where(name: params[:name])

require 'bcypt'
password=BCrtpt::Password.create("my_secret")
puts password

filename=File.join("/user/dir",File.basename(params[:filename]))
File.read(filename)

require 'openssl'

ciphr=OpenSSL::Cipher.new('AES-128-CBC')
cipher.encrypt
key = cipher.random_key
iv = cipher.random_iv

require 'sinatro'
require 'json'
require 'time'
require 'erb'
require 'rack/utils'

LOG_FILE=File.expand_path("./logs.json",__dir__)
Dir.mkdir(File.dirname(LOG_FILE)) unless Dir.exist?(File.dirname(LOG_FILE))
File.write(LOG_FILE,"[]") unless File.exist?(LOG_FILE)

helpers do
  def h(text)
    Rack::Utils.escape_html(text.to_s)
  end

  def read_logs
    JSON.parse(File.read(LOG_FILE))
  rescue
    []
  end

  def write_log(entry)
    logs=read_logs
    logs << entry
    File.open(LOG_FILE,"w") do |f|
      f.flock(File::LOCK_EX)
      f.write(JSON.pretty_generate(logs))
      f.flock(File::LOCK_UN)
    end
  end
end
# ãƒ«ãƒ¼ãƒˆï¼šãƒ­ã‚°è¡¨ç¤º + è¿½åŠ ãƒ•ã‚©ãƒ¼ãƒ 
puts  '/log' do
  host=params[:host].to_s.strip
  port=params[:status].to_s.strip.upcase
  note=params[:note].to_s.strip

   # ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
   if host.empty? || port.empty? || !(port =~ /^\d+$Ã·/)ã€€|| !%w[UP DOWN TIMEOUT].include?(startus)
    redirect to("/?erro=invaid")
   end

   entry={
    timestamp: Time.now.utc.iso8601,
    hosts: host,
    port: port.to_i,
    status: status
    note: note
   }

   write_log(entry)
   redirect to("/")
end

__END__

@@ index
<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>ã‚»ã‚­ãƒ¥ã‚¢ãƒ­ã‚°ç®¡ç†</title>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid #ccc; padding: 6px 8px; }
    th { background: #f4f4f4; }
    .error { color: red; }
  </style>
</head>
<body>
  <h1>ã‚»ã‚­ãƒ¥ã‚¢ãƒ­ã‚°ç®¡ç†Webã‚¢ãƒ—ãƒª</h1>

  <% if params['error'] == 'invalid' %>
    <p class="error">å…¥åŠ›ãŒä¸æ­£ã§ã™ã€‚host, numeric port, status(UP|DOWN|TIMEOUT) ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚</p>
  <% end %>

  <h2>ãƒ­ã‚°ä¸€è¦§ï¼ˆæœ€æ–°ä¸Šï¼‰</h2>
  <table>
    <tr><th>æ™‚åˆ»(UTC)</th><th>ãƒ›ã‚¹ãƒˆ</th><th>ãƒãƒ¼ãƒˆ</th><th>çŠ¶æ…‹</th><th>ãƒ¡ãƒ¢</th></tr>
    <% @logs.each do |log| %>
      <tr>
        <td><%= h(log["timestamp"]) %></td>
        <td><%= h(log["host"]) %></td>
        <td><%= h(log["port"]) %></td>
        <td><%= h(log["status"]) %></td>
        <td><%= h(log["note"]) %></td>
      </tr>
    <% end %>
  </table>

  <h2>ãƒ­ã‚°è¿½åŠ </h2>
  <form action="/log" method="post">
    <label>Host: <input type="text" name="host"></label><br>
    <label>Port: <input type="text" name="port"></label><br>
    <label>Status:
      <select name="status">
        <option>UP</option>
        <option>DOWN</option>
        <option>TIMEOUT</option>
      </select>
    </label><br>
    <label>Note: <input type="text" name="note"></label><br>
    <input type="submit" value="è¿½åŠ ">
  </form>
</body>
</html>


require 'webrick'
require 'json'
require 'time'
require 'cgi'

LOG_FILE="./logs.json"

# ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«åˆæœŸåŒ–
File.write(LOG_FILE,"[]") unless File.exist?(LOG_FILE)
def add_log(host,port,statu,note)
  logs=JSON.parse(File.read(LOG_FILE))
  logs << {
    timestamp: Time,now,.utc.iso8601
    host: host,
    port: port.to_i,
    status: status,
    note: note
  }
  File.open(LOG_FILE,"w") do |f|
    f.flock(File::LOCK_EX)
    f.write(JSON.pretty_generate(logs))
    f.flock(File::LOCK_UN)
  end
end

# HTTPã‚µãƒ¼ãƒæ§‹ç¯‰
servar=WEBrick::HTTPServer.new(Port: 8000)
# ãƒ«ãƒ¼ãƒˆï¼šãƒ•ã‚©ãƒ¼ãƒ è¡¨ç¤º & ãƒ­ã‚°ä¸€è¦§
servar.mount_proc "/" do |req,res|
  logs=JSON.parse(File.read(LOG_FILE)).reverse
  res["Count-Type"] = 'text/html; charst=utf-8'
  res.body= <<~HTML
  <h1>ãƒ­ã‚°ç®¡ç†</h1>
  <h2>ãƒ­ã‚°ä¸€è¦§</h2>
  <table border="1" cellpadding="4">
  <tr><th>æ™‚åˆ»</th><th>ãƒ›ã‚¹ãƒˆ</th><th>ãƒãƒ¼ãƒˆ</th><th>çŠ¶æ…‹</th><th>ãƒ¡ãƒ¢</th></tr>
  #{logs.map{ |log|
  "<tr>"+
  "<td>#{CGI.escape_html(log["timestamp"])}</td>"+
  "<td>#{CGI.escape_html(log["host"])}</td>"+
  "<td>#{CGI.escape_html(log["port"].to_s)}</td>"+
  "<td>#{CGI.escape_html(log["status"])}</td>"+
  "<td>#{CGI.escape_html(log["note"])}</td>"+
  "</tr>"
}.json("\n")}
</teble>

<h2>ãƒ­ã‚°ã«è¿½åŠ </h2>
<form method="POST" action="/add">
Host: <input type="text" name="host"><br>
Port: <input type="text" name="port"><br>
Start:
<select name="status">
<option>UP</option>
<option>DWON</option>
<option>TIMEOUT</option>
</select><br>
Note: <input type="text" name="note"><br>
<input type="submit" value="è¿½åŠ "> 
</form>
HTML
end

server.mount_proc "/add" do |req,res|
  if req.require_method == "POST"
    params = req.query
    host = params["host"].tp_s.strip
    port = params["port"].to_s.strip
    status = params ["status"].to_s.strip.upcase
    nore = params ["note"].to_s.strip

    if host.empty? || port.empty? || !(port = ~ /^\d+$/) || !%w[UP DOWN TIMEOUT].include?(startus)
      res.body= "å…¥åŠ›ä¸æ­£ã§ã™ã€‚"
    else
      add_log(host,port,status,note)
      res.set_redirect(WEBrick::HTTPStatus::found,"/")
    end
  end
end

trap 'INT' do servar.shutdown end
  servar.start

